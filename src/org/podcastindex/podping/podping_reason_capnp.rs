// @generated by the capnpc-rust plugin to the Cap'n Proto schema compiler.
// DO NOT EDIT.
// source: org/podcastindex/podping/podping_reason.capnp


#[repr(u16)]
#[derive(Clone, Copy, Debug, PartialEq, Eq)]
pub enum PodpingReason {
  Update = 0,
  Live = 1,
  LiveEnd = 2,
}

impl ::capnp::introspect::Introspect for PodpingReason {
  fn introspect() -> ::capnp::introspect::Type { ::capnp::introspect::TypeVariant::Enum(::capnp::introspect::RawEnumSchema { encoded_node: &podping_reason::ENCODED_NODE, annotation_types: podping_reason::get_annotation_types }).into() }
}
impl <'a> ::core::convert::From<PodpingReason> for ::capnp::dynamic_value::Reader<'a> {
  fn from(e: PodpingReason) -> Self { ::capnp::dynamic_value::Enum::new(e.into(), ::capnp::introspect::RawEnumSchema { encoded_node: &podping_reason::ENCODED_NODE, annotation_types: podping_reason::get_annotation_types }.into()).into() }
}
impl ::core::convert::TryFrom<u16> for PodpingReason {
  type Error = ::capnp::NotInSchema;
  fn try_from(value: u16) -> ::core::result::Result<Self, <PodpingReason as ::core::convert::TryFrom<u16>>::Error> {
    match value {
      0 => ::core::result::Result::Ok(Self::Update),
      1 => ::core::result::Result::Ok(Self::Live),
      2 => ::core::result::Result::Ok(Self::LiveEnd),
      n => ::core::result::Result::Err(::capnp::NotInSchema(n)),
    }
  }
}
impl From<PodpingReason> for u16 {
  #[inline]
  fn from(x: PodpingReason) -> u16 { x as u16 }
}
impl ::capnp::traits::HasTypeId for PodpingReason {
  const TYPE_ID: u64 = 0xd99a_1fdf_acec_bc89u64;
}
mod podping_reason {
pub static ENCODED_NODE: [::capnp::Word; 34] = [
  ::capnp::word(0, 0, 0, 0, 5, 0, 6, 0),
  ::capnp::word(137, 188, 236, 172, 223, 31, 154, 217),
  ::capnp::word(46, 0, 0, 0, 2, 0, 0, 0),
  ::capnp::word(235, 100, 81, 164, 228, 223, 204, 154),
  ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
  ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
  ::capnp::word(21, 0, 0, 0, 226, 1, 0, 0),
  ::capnp::word(49, 0, 0, 0, 7, 0, 0, 0),
  ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
  ::capnp::word(45, 0, 0, 0, 79, 0, 0, 0),
  ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
  ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
  ::capnp::word(111, 114, 103, 47, 112, 111, 100, 99),
  ::capnp::word(97, 115, 116, 105, 110, 100, 101, 120),
  ::capnp::word(47, 112, 111, 100, 112, 105, 110, 103),
  ::capnp::word(47, 112, 111, 100, 112, 105, 110, 103),
  ::capnp::word(95, 114, 101, 97, 115, 111, 110, 46),
  ::capnp::word(99, 97, 112, 110, 112, 58, 80, 111),
  ::capnp::word(100, 112, 105, 110, 103, 82, 101, 97),
  ::capnp::word(115, 111, 110, 0, 0, 0, 0, 0),
  ::capnp::word(0, 0, 0, 0, 1, 0, 1, 0),
  ::capnp::word(12, 0, 0, 0, 1, 0, 2, 0),
  ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
  ::capnp::word(29, 0, 0, 0, 58, 0, 0, 0),
  ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
  ::capnp::word(1, 0, 0, 0, 0, 0, 0, 0),
  ::capnp::word(21, 0, 0, 0, 42, 0, 0, 0),
  ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
  ::capnp::word(2, 0, 0, 0, 0, 0, 0, 0),
  ::capnp::word(13, 0, 0, 0, 66, 0, 0, 0),
  ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
  ::capnp::word(117, 112, 100, 97, 116, 101, 0, 0),
  ::capnp::word(108, 105, 118, 101, 0, 0, 0, 0),
  ::capnp::word(108, 105, 118, 101, 69, 110, 100, 0),
];
pub fn get_annotation_types(child_index: Option<u16>, index: u32) -> ::capnp::introspect::Type {
  panic!("invalid annotation indices ({:?}, {}) ", child_index, index)
}
}
